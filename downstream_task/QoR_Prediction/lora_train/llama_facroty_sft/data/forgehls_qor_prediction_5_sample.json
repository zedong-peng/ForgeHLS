[{"instruction": "Given the HLS code snippet below, predict the hardware implementation latency and resource usage (LUTs, DSPs, FFs). Output the results in JSON format without additional text: {\u201clatency\u201d: X, \u201clut\u201d: Y, \u201cdsp\u201d: Z, \u201cff\u201d: W}.", "input": "#include <ap_int.h>\n\nvoid binary_adder_fast_carry1(ap_uint<4> a, ap_uint<4> b, ap_uint<1> cin, ap_uint<4>& sum, ap_uint<1>& cout) {\n    ap_uint<5> temp = a.to_uint() + b.to_uint() + cin.to_uint();\n    sum = temp.range(3, 0);\n    cout = temp[4];\n}\n", "output": "{latency: 0, lut: 20, dsp: 0, ff: 0}"},
{"instruction": "Given the HLS code snippet below, predict the hardware implementation latency and resource usage (LUTs, DSPs, FFs). Output the results in JSON format without additional text: {\u201clatency\u201d: X, \u201clut\u201d: Y, \u201cdsp\u201d: Z, \u201cff\u201d: W}.", "input": "#include <hls_stream.h>\n\nvoid full_adder_1(const bool a[4], const bool b[4], const bool carry_in, bool sum[4], bool& carry_out) {\n#pragma HLS ARRAY_PARTITION variable=sum type=cyclic dim=1 factor=1\n#pragma HLS ARRAY_PARTITION variable=b type=cyclic dim=1 factor=2\n#pragma HLS ARRAY_PARTITION variable=a type=cyclic dim=1 factor=2\n    bool carry = carry_in;\n\n    for (int i = 0; i < 4; i++) {\n#pragma HLS PIPELINE OFF \n#pragma HLS UNROLL factor=1\n        sum[i] = a[i] ^ b[i] ^ carry;\n        carry = (a[i] & b[i]) | (carry & (a[i] ^ b[i]));\n    }\n    carry_out = carry;\n}\n", "output": "{latency: 9, lut: 85, dsp: 0, ff: 11}"},
{"instruction": "Given the HLS code snippet below, predict the hardware implementation latency and resource usage (LUTs, DSPs, FFs). Output the results in JSON format without additional text: {\u201clatency\u201d: X, \u201clut\u201d: Y, \u201cdsp\u201d: Z, \u201cff\u201d: W}.", "input": "#include <ap_int.h>\n\nvoid full_adder_4bit(ap_uint<4> a, ap_uint<4> b, bool cin, ap_uint<4>& sum, bool& cout) {\n    ap_uint<4> tmp_a = a;\n    ap_uint<4> tmp_b = b;\n    bool carry = cin;\n\n    sum = 0;\n    for (int i = 0; i < 4; ++i) {\n#pragma HLS PIPELINE \n#pragma HLS UNROLL factor=2\n        sum[i] = tmp_a[i] ^ tmp_b[i] ^ carry; // Calculate sum\n        carry = (tmp_a[i] & tmp_b[i]) | (carry & (tmp_a[i] ^ tmp_b[i])); // Calculate carry\n    }\n    cout = carry; // Final carry out\n}\n", "output": "{latency: 4, lut: 165, dsp: 0, ff: 10}"},
{"instruction": "Given the HLS code snippet below, predict the hardware implementation latency and resource usage (LUTs, DSPs, FFs). Output the results in JSON format without additional text: {\u201clatency\u201d: X, \u201clut\u201d: Y, \u201cdsp\u201d: Z, \u201cff\u201d: W}.", "input": "#include <ap_int.h>\n\nvoid full_adder_4bit_2(const ap_uint<4>& A, const ap_uint<4>& B, const ap_uint<1>& Cin, \n                       ap_uint<4>& Sum, ap_uint<1>& Cout) {\n    ap_uint<1> carry = Cin;\n    for (int i = 0; i < 4; i++) {\n#pragma HLS PIPELINE OFF \n#pragma HLS UNROLL factor=1\n        ap_uint<1> sum_bit = A[i] ^ B[i] ^ carry;\n        carry = (A[i] & B[i]) | (carry & (A[i] ^ B[i]));\n        Sum[i] = sum_bit;\n    }\n    Cout = carry;\n}\n", "output": "{latency: 5, lut: 70, dsp: 0, ff: 10}"},
{"instruction": "Given the HLS code snippet below, predict the hardware implementation latency and resource usage (LUTs, DSPs, FFs). Output the results in JSON format without additional text: {\u201clatency\u201d: X, \u201clut\u201d: Y, \u201cdsp\u201d: Z, \u201cff\u201d: W}.", "input": "#include <cstdint>\n\nvoid barrel_shifter_3(uint32_t& data, uint8_t shift_amount, bool direction) {\n    const uint32_t mask = sizeof(data) * 8 - 1; // 32 bits for uint32_t\n    shift_amount &= mask; // Limit shift_amount to 0-31\n\n    if (direction) { // Right shift\n        data = (data >> shift_amount) | (data << (mask - shift_amount));\n    } else { // Left shift\n        data = (data << shift_amount) | (data >> (mask - shift_amount));\n    }\n}\n", "output": "{latency: 0, lut: 469, dsp: 0, ff: 0}"}]